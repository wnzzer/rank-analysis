name: Release Build

on:
  workflow_dispatch:
    inputs:
      notes:
        description: 'Release Notes (optional)'
        required: false
        default: ''

permissions:
  contents: write

jobs:
  build-and-release:
    name: Build & Upload Assets (Windows)
    runs-on: windows-latest
    
    # å®šä¹‰å…¨å±€å·¥ä½œç›®å½•ï¼Œé€‚ç”¨äºæ‰€æœ‰ run æ­¥éª¤
    defaults:
      run:
        working-directory: ./lol-record-analysis-tauri
    
    # å¯¼å‡ºç‰ˆæœ¬å·ç»™ä¸‹ä¸€ä¸ª Job ä½¿ç”¨
    outputs:
      tauri_version: ${{ steps.get_version.outputs.tauri_version }}

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ› ï¸ Setup Node.js (v20)
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: lol-record-analysis-tauri/package-lock.json

      - name: ğŸ¦€ Install Rust Toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: ğŸ“¦ Install dependencies
        run: npm ci

      # --- æ ¸å¿ƒæ­¥éª¤ï¼šæ™ºèƒ½è·å–ç‰ˆæœ¬å· ---
      - name: ğŸ” Get App Version
        id: get_version
        shell: pwsh
        run: |
          $configPath = "src-tauri/tauri.conf.json"
          # è¯»å– JSON é…ç½®
          $configJson = Get-Content $configPath | Out-String | ConvertFrom-Json
          
          # å°è¯•è¯»å– version (é€‚é… Tauri v1 package.version å’Œ Tauri v2 top-level version)
          if ($configJson.version) {
              $tauriVersion = $configJson.version
          } elseif ($configJson.package.version) {
              $tauriVersion = $configJson.package.version
          }

          # å¦‚æœä¸ºç©ºï¼Œå°è¯•è¯»å– Cargo.toml
          if ([string]::IsNullOrEmpty($tauriVersion)) {
              Write-Host "tauri.conf.json version is empty. Checking Cargo.toml..."
              $tomlPath = "src-tauri/Cargo.toml"
              $tomlContent = Get-Content $tomlPath | Select-String -Pattern '^version\s*=\s*"(.+?)"' 
              
              if ($tomlContent) {
                  $tauriVersion = $tomlContent.Matches[0].Groups[1].Value
              } else {
                  Write-Error "Could not find version in tauri.conf.json or Cargo.toml"
                  exit 1
              }
          }
          Write-Host "Detected Tauri Version: $tauriVersion"

          # ç¡®ä¿ç‰ˆæœ¬å·ä»¥ 'v' å¼€å¤´ (GitHub Release æƒ¯ä¾‹)
          if ($tauriVersion -notlike 'v*') {
              $tauriVersion = "v$tauriVersion"
          }
          
          Write-Host "Final Release Version: $tauriVersion"
          echo "tauri_version=$tauriVersion" >> $env:GITHUB_OUTPUT

      - name: ğŸ•µï¸ Debug Secrets (Safe)
        shell: pwsh
        run: |
          if ($env:MY_KEY) { 
              Write-Host "âœ… Private Key is detected! Length: $($env:MY_KEY.Length)" 
              # Check if it looks like a minisign key
              if ($env:MY_KEY -match "untrusted comment:") {
                  Write-Host "âœ… Key format looks correct (contains 'untrusted comment')."
              } else {
                  Write-Warning "âš ï¸ Key format might be incorrect. It should usually start with 'untrusted comment:'."
              }
          } else { 
              Write-Error "âŒ Private Key is MISSING or EMPTY!" 
          }
          
          if ($env:MY_PWD) { 
              Write-Host "âœ… Password is detected!" 
          } else { 
              Write-Warning "âš ï¸ Password is MISSING (If you have no password, ignore this)" 
          }
        env:
          MY_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          MY_PWD: ${{ secrets.TAURI_SIGNING_KEY_PASSWORD }}

      # --- æ„å»ºå¹¶ç­¾å ---
      - name: ğŸ”¨ Build Tauri App (Signed)
        run: npm run tauri build
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_KEY_PASSWORD }}
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }} # å…¼å®¹æ—§ç‰ˆ
          TAURI_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_KEY_PASSWORD }}
          TAURI_SIGNING_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_KEY_PASSWORD }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_KEY_PASSWORD }} # å…¼å®¹æ—§ç‰ˆ

      - name: ğŸ“‚ List Build Artifacts (Debug)
        shell: pwsh
        run: |
          Write-Host "Listing src-tauri/target/release/bundle/nsis:"
          Get-ChildItem -Path "src-tauri/target/release/bundle/nsis" -Recurse | Format-Table Name, Length, LastWriteTime


      # --- æ–‡ä»¶é‡å‘½åã€å‹ç¼©ä¸è·¯å¾„æ•´ç† ---
      - name: ğŸ“ Rename, Compress, and Set Paths
        id: prepare_assets
        shell: pwsh
        run: |
          # è·å–ä¸Šä¸€æ­¥è§£æå‡ºçš„ç‰ˆæœ¬å·
          $version = "${{ steps.get_version.outputs.tauri_version }}" 
          $cleanVersion = $version -replace '^v',''
          
          $nsisDir = "src-tauri/target/release/bundle/nsis"
          $releaseDir = "src-tauri/target/release"
          $appName = "lol-record-analysis-app"

          # 1. å¤„ç†å®‰è£…åŒ… (.exe) å’Œ ç­¾åæ–‡ä»¶ (.sig)
          $installerFile = Get-ChildItem -Path $nsisDir -Filter "*.exe" -ErrorAction Stop
          $sigFile = Get-ChildItem -Path $nsisDir -Filter "*.sig" -ErrorAction SilentlyContinue

          if ($installerFile.Count -ne 1) { 
            Write-Error "Expected 1 installer file, found $($installerFile.Count)"
            exit 1 
          }
          
          $setupName = "$appName-$cleanVersion-setup.exe"
          Rename-Item -Path $installerFile[0].FullName -NewName $setupName

          $sigPath = ""
            $sigName = "$setupName.sig"
            if ($sigFile.Count -gt 0) {
              # å¦‚æœ tauri build å·²ç»ç”Ÿæˆäº†ç­¾åæ–‡ä»¶ï¼Œç»Ÿä¸€æ”¹åä¸ºä¸å®‰è£…åŒ…ä¸€è‡´
              Rename-Item -Path $sigFile[0].FullName -NewName $sigName
            } else {
              # ä¸€äº› Tauri / bundler ç»„åˆä¸ä¼šåœ¨ NSIS ç›®å½•ä¸‹è‡ªåŠ¨è¾“å‡º .sig
              # è¿™é‡Œæ˜¾å¼å¯¹â€œå®‰è£…åŒ…æ–‡ä»¶æœ¬èº«â€ç”Ÿæˆ updater ç”¨çš„ minisign ç­¾å
              Write-Host "No .sig found in NSIS output. Generating with 'tauri signer sign'..."

              $installerPath = Join-Path $nsisDir $setupName
              if (-not (Test-Path $installerPath)) {
                Write-Error "Installer not found at $installerPath"
                exit 1
              }

              if ([string]::IsNullOrEmpty($env:TAURI_PRIVATE_KEY)) {
                Write-Error "TAURI_PRIVATE_KEY is missing; cannot sign installer."
                exit 1
              }

              # å¦‚æœä½ çš„ key æ˜¯ç©ºå¯†ç ï¼Œè¿™é‡Œä¿è¯å˜é‡å­˜åœ¨ï¼Œé¿å… CLI äº¤äº’æç¤º
              if ($null -eq $env:TAURI_PRIVATE_KEY_PASSWORD) {
                $env:TAURI_PRIVATE_KEY_PASSWORD = ""
              }

              npx tauri signer sign "$installerPath"
            }

            $sigCandidate = Join-Path $nsisDir $sigName
            if (Test-Path $sigCandidate) {
              $sigPath = "$($env:GITHUB_WORKSPACE)/lol-record-analysis-tauri/$nsisDir/$sigName"
            } else {
                Write-Error "Signature file missing: $sigCandidate"
                exit 1
            }

          # 2. å¤„ç†ç»¿è‰²ç‰ˆ (Portable .7z)
          $exeName = "$appName.exe"
          $portable7zName = "$appName-$cleanVersion-portable.7z"
          
          if (Test-Path "$releaseDir/$exeName") {
            Push-Location $releaseDir
            7z a -t7z $portable7zName $exeName
            Pop-Location
          } else {
            Write-Error "Main executable not found for portable packing."
            exit 1
          }

          # 3. è¾“å‡ºä¾› Release æ­¥éª¤ä½¿ç”¨çš„è·¯å¾„
          $setupPath = "$($env:GITHUB_WORKSPACE)/lol-record-analysis-tauri/$nsisDir/$setupName"
          $portablePath = "$($env:GITHUB_WORKSPACE)/lol-record-analysis-tauri/$releaseDir/$portable7zName"
          
          echo "setup_path=$setupPath" >> $env:GITHUB_OUTPUT
          echo "portable_path=$portablePath" >> $env:GITHUB_OUTPUT
          echo "sig_path=$sigPath" >> $env:GITHUB_OUTPUT 
        env:
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_KEY_PASSWORD }}

      - name: âš¡ Install git-cliff
        uses: taiki-e/install-action@v2
        with:
          tool: git-cliff

      - name: ğŸ“ Generate Changelog
        working-directory: .
        run: git-cliff --config .github/cliff.toml --verbose --tag ${{ steps.get_version.outputs.tauri_version }} --unreleased --strip header --output lol-record-analysis-tauri/CHANGELOG.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ“„ Prepare Release Body
        shell: pwsh
        run: |
          $notes = "${{ github.event.inputs.notes }}"
          # ç°åœ¨çš„ CHANGELOG.md å°±åœ¨å½“å‰çš„å·¥ä½œç›®å½•ä¸­ (lol-record-analysis-tauri)
          $changelog = Get-Content CHANGELOG.md -Raw
          
          if (-not [string]::IsNullOrWhiteSpace($notes)) {
              Set-Content -Path RELEASE_BODY.md -Value "$notes`n`n$changelog"
          } else {
              Set-Content -Path RELEASE_BODY.md -Value $changelog
          }
        
      # --- åˆ›å»º Release å¹¶ä¸Šä¼ èµ„æº ---
      - name: ğŸš€ Create GitHub Release and Upload Assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.get_version.outputs.tauri_version }}
          name: Release ${{ steps.get_version.outputs.tauri_version }}
          body_path: lol-record-analysis-tauri/RELEASE_BODY.md
          files: |
            ${{ steps.prepare_assets.outputs.setup_path }}
            ${{ steps.prepare_assets.outputs.portable_path }}
          draft: false
          prerelease: false

      # --- ç”Ÿæˆ latest.json ---
      - name: ğŸ“ Generate latest.json
        run: |
          node -e '
            const fs = require("fs");
            const path = require("path");
            
            const version = process.env.VERSION;
            const setupPath = process.env.SETUP_PATH;
            const sigPath = process.env.SIG_PATH;
            
            // å°è¯•è¯»å–è‡ªåŠ¨ç”Ÿæˆçš„ RELEASE_BODY.md
            let autoNotes = "";
            try {
                if (fs.existsSync("RELEASE_BODY.md")) {
                    autoNotes = fs.readFileSync("RELEASE_BODY.md", "utf8");
                }
            } catch (e) {
                console.warn("Could not read RELEASE_BODY.md", e);
            }

            // ä¼˜å…ˆä½¿ç”¨ç”Ÿæˆçš„ bodyï¼ˆåŒ…å«æ‰‹åŠ¨è¾“å…¥+è‡ªåŠ¨æ—¥å¿—ï¼‰ï¼Œå…¶æ¬¡å›é€€
            const notes = autoNotes || process.env.NOTES || "For details, please check the GitHub Release page.";

            const exeFile = path.basename(setupPath);
            let signature = "";
            
            if (sigPath && fs.existsSync(sigPath)) {
                signature = fs.readFileSync(sigPath, "utf8");
                console.log("Signature loaded successfully.");
            } else {
                console.warn("WARNING: Signature file missing or empty.");
            }
            
            const data = {
                version: version,
                notes: notes,
                pub_date: new Date().toISOString(),
                platforms: {
                    "windows-x86_64": {
                        signature: signature,
                        url: `https://github.com/wnzzer/rank-analysis/releases/download/${version}/${exeFile}`
                    }
                }
            };
            
            fs.writeFileSync("latest.json", JSON.stringify(data, null, 2));
            console.log("latest.json generated.");
          '
        env:
          VERSION: ${{ steps.get_version.outputs.tauri_version }}
          NOTES: ${{ github.event.inputs.notes }}
          SETUP_PATH: ${{ steps.prepare_assets.outputs.setup_path }}
          SIG_PATH: ${{ steps.prepare_assets.outputs.sig_path }}

      # --- ä¸Šä¼  latest.json ---
      - name: â¬†ï¸ Upload latest.json Asset
        uses: softprops/action-gh-release@v2 
        with:
          tag_name: ${{ steps.get_version.outputs.tauri_version }}
          files: lol-record-analysis-tauri/latest.json


  # --- ä»»åŠ¡äºŒï¼šé€šçŸ¥ UpgradeLink ---
  upgradelink-upload:
    name: Notify UpgradeLink Service
    needs: build-and-release
    permissions:
      contents: write 
    runs-on: ubuntu-latest
    
    steps:
      - name: â³ Wait for Release Assets
        run: sleep 30 

      - name: ğŸ”— Send a request to UpgradeLink
        uses: toolsetlink/upgradelink-action@v5
        with:
          # ä½¿ç”¨ needs.build-and-release.outputs.tauri_version è·å–ç‰ˆæœ¬å·
          source-url: 'https://github.com/wnzzer/rank-analysis/releases/download/${{ needs.build-and-release.outputs.tauri_version }}/latest.json'
          access-key: ${{ secrets.UPGRADE_LINK_ACCESS_KEY }}
          tauri-key: ${{ secrets.UPGRADE_LINK_TAURI_KEY }}
          github-token: ${{ secrets.GITHUB_TOKEN }}